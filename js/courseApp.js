var sequencePatterns = [
	"A",
	"B",
	"C",
	"D",
	"E",
	"F",
	"G",
	"H",
	"I",
	"J",
	"K",
	"L",
	"M",
	"N",
	"O",
	"P",
	"Q",
	"R",
	"S",
	"T",
	"U",
	"V",
	"W",
	"X",
	"Y",
	"Z",
	"000",
	"001",
	"002",
	"003",
	"004",
	"005",
	"006",
	"007",
	"008",
	"009",
	"010",
	"011",
	"012",
	"013",
	"014",
	"015",
	"016",
	"017",
	"018",
	"019",
	"020",
	"021",
	"022",
	"023",
	"024",
	"025",
	"026",
	"027",
	"028",
	"029",
	"030",
	"031",
	"032",
	"033",
	"034",
	"035",
	"036",
	"037",
	"038",
	"039",
	"040",
	"041",
	"042",
	"043",
	"044",
	"045",
	"046",
	"047",
	"048",
	"049",
	"050",
	"051",
	"052",
	"053",
	"054",
	"055",
	"056",
	"057",
	"058",
	"059",
	"060",
	"061",
	"062",
	"063",
	"064",
	"065",
	"066",
	"067",
	"068",
	"069",
	"070",
	"071",
	"072",
	"073",
	"074",
	"075",
	"076",
	"077",
	"078",
	"079",
	"080",
	"081",
	"082",
	"083",
	"084",
	"085",
	"086",
	"087",
	"088",
	"089",
	"090",
	"091",
	"092",
	"093",
	"094",
	"095",
	"096",
	"097",
	"098",
	"099",
	"100",
	"101",
	"102",
	"103",
	"104",
	"105",
	"106",
	"107",
	"108",
	"109",
	"110",
	"111",
	"112",
	"113",
	"114",
	"115",
	"116",
	"117",
	"118",
	"119",
	"120",
	"121",
	"122",
	"123",
	"124",
	"125",
	"126",
	"127",
	"128",
	"129",
	"130",
	"131",
	"132",
	"133",
	"134",
	"135",
	"136",
	"137",
	"138",
	"139",
	"140",
	"141",
	"142",
	"143",
	"144",
	"145",
	"146",
	"147",
	"148",
	"149",
	"150",
	"151",
	"152",
	"153",
	"154",
	"155",
	"156",
	"157",
	"158",
	"159",
	"160",
	"161",
	"162",
	"163",
	"164",
	"165",
	"166",
	"167",
	"168",
	"169",
	"170",
	"171",
	"172",
	"173",
	"174",
	"175",
	"176",
	"177",
	"178",
	"179",
	"180",
	"181",
	"182",
	"183",
	"184",
	"185",
	"186",
	"187",
	"188",
	"189",
	"190",
	"191",
	"192",
	"193",
	"194",
	"195",
	"196",
	"197",
	"198",
	"199",
	"200",
	"201",
	"202",
	"203",
	"204",
	"205",
	"206",
	"207",
	"208",
	"209",
	"210",
	"211",
	"212",
	"213",
	"214",
	"215",
	"216",
	"217",
	"218",
	"219",
	"220",
	"221",
	"222",
	"223",
	"224",
	"225",
	"226",
	"227",
	"228",
	"229",
	"230",
	"231",
	"232",
	"233",
	"234",
	"235",
	"236",
	"237",
	"238",
	"239",
	"240",
	"241",
	"242",
	"243",
	"244",
	"245",
	"246",
	"247",
	"248",
	"249",
	"250",
	"251",
	"252",
	"253",
	"254",
	"255",
	"256",
	"257",
	"258",
	"259",
	"260",
	"261",
	"262",
	"263",
	"264",
	"265",
	"266",
	"267",
	"268",
	"269",
	"270",
	"271",
	"272",
	"273",
	"274",
	"275",
	"276",
	"277",
	"278",
	"279",
	"280",
	"281",
	"282",
	"283",
	"284",
	"285",
	"286",
	"287",
	"288",
	"289",
	"290",
	"291",
	"292",
	"293",
	"294",
	"295",
	"296",
	"297",
	"298",
	"299",
	"300",
	"301",
	"302",
	"303",
	"304",
	"305",
	"306",
	"307",
	"308",
	"309",
	"310",
	"311",
	"312",
	"313",
	"314",
	"315",
	"316",
	"317",
	"318",
	"319",
	"320",
	"321",
	"322",
	"323",
	"324",
	"325",
	"326",
	"327",
	"328",
	"329",
	"330",
	"331",
	"332",
	"333",
	"334",
	"335",
	"336",
	"337",
	"338",
	"339",
	"340",
	"341",
	"342",
	"343",
	"344",
	"345",
	"346",
	"347",
	"348",
	"349",
	"350",
	"351",
	"352",
	"353",
	"354",
	"355",
	"356",
	"357",
	"358",
	"359",
	"360",
	"361",
	"362",
	"363",
	"364",
	"365",
	"366",
	"367",
	"368",
	"369",
	"370",
	"371",
	"372",
	"373",
	"374",
	"375",
	"376",
	"377",
	"378",
	"379",
	"380",
	"381",
	"382",
	"383",
	"384",
	"385",
	"386",
	"387",
	"388",
	"389",
	"390",
	"391",
	"392",
	"393",
	"394",
	"395",
	"396",
	"397",
	"398",
	"399",
	"400",
	"401",
	"402",
	"403",
	"404",
	"405",
	"406",
	"407",
	"408",
	"409",
	"410",
	"411",
	"412",
	"413",
	"414",
	"415",
	"416",
	"417",
	"418",
	"419",
	"420",
	"421",
	"422",
	"423",
	"424",
	"425",
	"426",
	"427",
	"428",
	"429",
	"430",
	"431",
	"432",
	"433",
	"434",
	"435",
	"436",
	"437",
	"438",
	"439",
	"440",
	"441",
	"442",
	"443",
	"444",
	"445",
	"446",
	"447",
	"448",
	"449",
	"450",
	"451",
	"452",
	"453",
	"454",
	"455",
	"456",
	"457",
	"458",
	"459",
	"460",
	"461",
	"462",
	"463",
	"464",
	"465",
	"466",
	"467",
	"468",
	"469",
	"470",
	"471",
	"472",
	"473",
	"474",
	"475",
	"476",
	"477",
	"478",
	"479",
	"480",
	"481",
	"482",
	"483",
	"484",
	"485",
	"486",
	"487",
	"488",
	"489",
	"490",
	"491",
	"492",
	"493",
	"494",
	"495",
	"496",
	"497",
	"498",
	"499",
	"500",
	"501",
	"502",
	"503",
	"504",
	"505",
	"506",
	"507",
	"508",
	"509",
	"510",
	"511",
	"512",
	"513",
	"514",
	"515",
	"516",
	"517",
	"518",
	"519",
	"520",
	"521",
	"522",
	"523",
	"524",
	"525",
	"526",
	"527",
	"528",
	"529",
	"530",
	"531",
	"532",
	"533",
	"534",
	"535",
	"536",
	"537",
	"538",
	"539",
	"540",
	"541",
	"542",
	"543",
	"544",
	"545",
	"546",
	"547",
	"548",
	"549",
	"550",
	"551",
	"552",
	"553",
	"554",
	"555",
	"556",
	"557",
	"558",
	"559",
	"560",
	"561",
	"562",
	"563",
	"564",
	"565",
	"566",
	"567",
	"568",
	"569",
	"570",
	"571",
	"572",
	"573",
	"574",
	"575",
	"576",
	"577",
	"578",
	"579",
	"580",
	"581",
	"582",
	"583",
	"584",
	"585",
	"586",
	"587",
	"588",
	"589",
	"590",
	"591",
	"592",
	"593",
	"594",
	"595",
	"596",
	"597",
	"598",
	"599",
	"600",
	"601",
	"602",
	"603",
	"604",
	"605",
	"606",
	"607",
	"608",
	"609",
	"610",
	"611",
	"612",
	"613",
	"614",
	"615",
	"616",
	"617",
	"618",
	"619",
	"620",
	"621",
	"622",
	"623",
	"624",
	"625",
	"626",
	"627",
	"628",
	"629",
	"630",
	"631",
	"632",
	"633",
	"634",
	"635",
	"636",
	"637",
	"638",
	"639",
	"640",
	"641",
	"642",
	"643",
	"644",
	"645",
	"646",
	"647",
	"648",
	"649",
	"650",
	"651",
	"652",
	"653",
	"654",
	"655",
	"656",
	"657",
	"658",
	"659",
	"660",
	"661",
	"662",
	"663",
	"664",
	"665",
	"666",
	"667",
	"668",
	"669",
	"670",
	"671",
	"672",
	"673",
	"674",
	"675",
	"676",
	"677",
	"678",
	"679",
	"680",
	"681",
	"682",
	"683",
	"684",
	"685",
	"686",
	"687",
	"688",
	"689",
	"690",
	"691",
	"692",
	"693",
	"694",
	"695",
	"696",
	"697",
	"698",
	"699",
	"700",
	"701",
	"702",
	"703",
	"704",
	"705",
	"706",
	"707",
	"708",
	"709",
	"710",
	"711",
	"712",
	"713",
	"714",
	"715",
	"716",
	"717",
	"718",
	"719",
	"720",
	"721",
	"722",
	"723",
	"724",
	"725",
	"726",
	"727",
	"728",
	"729",
	"730",
	"731",
	"732",
	"733",
	"734",
	"735",
	"736",
	"737",
	"738",
	"739",
	"740",
	"741",
	"742",
	"743",
	"744",
	"745",
	"746",
	"747",
	"748",
	"749",
	"750",
	"751",
	"752",
	"753",
	"754",
	"755",
	"756",
	"757",
	"758",
	"759",
	"760",
	"761",
	"762",
	"763",
	"764",
	"765",
	"766",
	"767",
	"768",
	"769",
	"770",
	"771",
	"772",
	"773",
	"774",
	"775",
	"776",
	"777",
	"778",
	"779",
	"780",
	"781",
	"782",
	"783",
	"784",
	"785",
	"786",
	"787",
	"788",
	"789",
	"790",
	"791",
	"792",
	"793",
	"794",
	"795",
	"796",
	"797",
	"798",
	"799",
	"800",
	"801",
	"802",
	"803",
	"804",
	"805",
	"806",
	"807",
	"808",
	"809",
	"810",
	"811",
	"812",
	"813",
	"814",
	"815",
	"816",
	"817",
	"818",
	"819",
	"820",
	"821",
	"822",
	"823",
	"824",
	"825",
	"826",
	"827",
	"828",
	"829",
	"830",
	"831",
	"832",
	"833",
	"834",
	"835",
	"836",
	"837",
	"838",
	"839",
	"840",
	"841",
	"842",
	"843",
	"844",
	"845",
	"846",
	"847",
	"848",
	"849",
	"850",
	"851",
	"852",
	"853",
	"854",
	"855",
	"856",
	"857",
	"858",
	"859",
	"860",
	"861",
	"862",
	"863",
	"864",
	"865",
	"866",
	"867",
	"868",
	"869",
	"870",
	"871",
	"872",
	"873",
	"874",
	"875",
	"876",
	"877",
	"878",
	"879",
	"880",
	"881",
	"882",
	"883",
	"884",
	"885",
	"886",
	"887",
	"888",
	"889",
	"890",
	"891",
	"892",
	"893",
	"894",
	"895",
	"896",
	"897",
	"898",
	"899",
	"900",
	"901",
	"902",
	"903",
	"904",
	"905",
	"906",
	"907",
	"908",
	"909",
	"910",
	"911",
	"912",
	"913",
	"914",
	"915",
	"916",
	"917",
	"918",
	"919",
	"920",
	"921",
	"922",
	"923",
	"924",
	"925",
	"926",
	"927",
	"928",
	"929",
	"930",
	"931",
	"932",
	"933",
	"934",
	"935",
	"936",
	"937",
	"938",
	"939",
	"940",
	"941",
	"942",
	"943",
	"944",
	"945",
	"946",
	"947",
	"948",
	"949",
	"950",
	"951",
	"952",
	"953",
	"954",
	"955",
	"956",
	"957",
	"958",
	"959",
	"960",
	"961",
	"962",
	"963",
	"964",
	"965",
	"966",
	"967",
	"968",
	"969",
	"970",
	"971",
	"972",
	"973",
	"974",
	"975",
	"976",
	"977",
	"978",
	"979",
	"980",
	"981",
	"982",
	"983",
	"984",
	"985",
	"986",
	"987",
	"988",
	"989",
	"990",
	"991",
	"992",
	"993",
	"994",
	"995",
	"996",
	"997",
	"998",
	"999"
];

var subjectCodes = [
	'AAS',
	'AASN',
	'ABG',
	'ABI',
	'ABS',
	'ABSC',
	'ABSN',
	'ABT',
	'ABTC',
	'ACC',
	'ADM',
	'ADSN',
	'AED',
	'AERN',
	'AET',
	'AGC',
	'AGE',
	'AGEN',
	'AGR',
	'AGRE',
	'AGS',
	'AGSE',
	'AHE',
	'AHI',
	'AHIA',
	'AHIC',
	'AHIE',
	'AHIN',
	'AHIW',
	'ALL',
	'AMR',
	'AMS',
	'AMSE',
	'AMSN',
	'AMSW',
	'ANA',
	'ANAN',
	'ANB',
	'ANE',
	'ANG',
	'ANS',
	'ANSN',
	'ANT',
	'ANTB',
	'ANTC',
	'ANTE',
	'ANTL',
	'ANTN',
	'ANTW',
	'APC',
	'APIN',
	'APR',
	'ARB',
	'ARBE',
	'ARBN',
	'ARC',
	'ARCE',
	'ARCN',
	'ARE',
	'AREN',
	'ARHN',
	'ARMN',
	'ART',
	'ARTC',
	'ARTE',
	'ARTN',
	'ARTS',
	'ARTW',
	'ASA',
	'ASAE',
	'ASAN',
	'ASCN',
	'ASE',
	'ASM',
	'AST',
	'ASTC',
	'ASTN',
	'ATM',
	'ATML',
	'ATMN',
	'AVS',
	'BAC',
	'BCB',
	'BCH',
	'BCHN',
	'BCM',
	'BCMD',
	'BCME',
	'BCMN',
	'BCP',
	'BCPN',
	'BEH',
	'BESN',
	'BIM',
	'BIO',
	'BIOD',
	'BIOE',
	'BIOL',
	'BION',
	'BIS',
	'BISC',
	'BISE',
	'BISI',
	'BISN',
	'BIT',
	'BMB',
	'BMBN',
	'BOT',
	'BOTE',
	'BOTN',
	'BPH',
	'BPT',
	'BST',
	'BUAC',
	'BUAE',
	'BUAN',
	'BUAW',
	'CAN',
	'CANC',
	'CAR',
	'CDB',
	'CDM',
	'CELC',
	'CHA',
	'CHAN',
	'CHE',
	'CHEC',
	'CHED',
	'CHEE',
	'CHEN',
	'CHES',
	'CHI',
	'CHIN',
	'CHIW',
	'CHN',
	'CHNE',
	'CHNN',
	'CLA',
	'CLAC',
	'CLAE',
	'CLAN',
	'CLH',
	'CLP',
	'CMH',
	'CMME',
	'CMMN',
	'CMN',
	'CMNW',
	'CMP',
	'CNE',
	'CNS',
	'CNT',
	'COM',
	'COME',
	'COMN',
	'CPS',
	'CRD',
	'CRI',
	'CROC',
	'CRSN',
	'CSI',
	'CSIC',
	'CSID',
	'CSIN',
	'CSM',
	'CST',
	'CTS',
	'CYPN',
	'DANE',
	'DEB',
	'DER',
	'DES',
	'DESE',
	'DRA',
	'DRAE',
	'DRAN',
	'DRAW',
	'DUTN',
	'DVBN',
	'DVM',
	'DVSN',
	'EAD',
	'EADN',
	'EAE',
	'EAL',
	'EALN',
	'EAP',
	'EAP1',
	'EAP5',
	'EAP6',
	'EAP7',
	'EAPE',
	'EAS',
	'EASC',
	'EASE',
	'EASN',
	'EBS',
	'EBSC',
	'ECH',
	'ECHN',
	'ECI',
	'ECIC',
	'ECIN',
	'ECL',
	'ECLC',
	'ECLE',
	'ECLN',
	'ECM',
	'ECN',
	'ECNC',
	'ECNE',
	'ECNL',
	'ECNN',
	'ECNS',
	'ECNW',
	'ECNY',
	'ECS',
	'ECSC',
	'ECSD',
	'ECSE',
	'ECSN',
	'EDEN',
	'EDO',
	'EDU',
	'EDUC',
	'EDUE',
	'EDUN',
	'EDUW',
	'EEC',
	'EECC',
	'EECE',
	'EECN',
	'EJS',
	'ELTN',
	'EME',
	'EMEE',
	'EMEN',
	'EMR',
	'EMS',
	'EMSC',
	'EMSN',
	'ENA',
	'END',
	'ENDN',
	'ENE',
	'ENEC',
	'ENEE',
	'ENEN',
	'ENG',
	'ENGB',
	'ENGC',
	'ENGE',
	'ENGN',
	'ENH',
	'ENHC',
	'ENL',
	'ENLC',
	'ENLD',
	'ENLE',
	'ENLN',
	'ENLW',
	'ENM',
	'ENMN',
	'ENP',
	'ENPN',
	'ENRN',
	'ENT',
	'ENTN',
	'EPI',
	'EPM',
	'EPP',
	'ERGN',
	'ERS',
	'ESM',
	'ESP',
	'ESPW',
	'ESR',
	'EST',
	'ESTC',
	'ESTD',
	'ESTE',
	'ESTN',
	'ETX',
	'EVE',
	'EVSC',
	'EXB',
	'EXS',
	'FAP',
	'FCON',
	'FLKN',
	'FLMN',
	'FMS',
	'FMSW',
	'FOR',
	'FPS',
	'FRE',
	'FREC',
	'FREE',
	'FREN',
	'FRMN',
	'FRS',
	'FSM',
	'FST',
	'FSTN',
	'GAS',
	'GDB',
	'GEL',
	'GELE',
	'GELN',
	'GELW',
	'GEN',
	'GENN',
	'GEO',
	'GEOC',
	'GEOE',
	'GEON',
	'GER',
	'GERE',
	'GERN',
	'GGG',
	'GMD',
	'GRK',
	'GRKN',
	'HAN',
	'HANN',
	'HDE',
	'HDEN',
	'HDEW',
	'HEB',
	'HEBC',
	'HEBE',
	'HEBN',
	'HEC',
	'HEE',
	'HIN',
	'HINE',
	'HINN',
	'HIS',
	'HISB',
	'HISC',
	'HISD',
	'HISE',
	'HISL',
	'HISN',
	'HISQ',
	'HISS',
	'HISW',
	'HMR',
	'HNR',
	'HON',
	'HPH',
	'HPHN',
	'HPS',
	'HRT',
	'HUM',
	'HUMW',
	'HUNE',
	'HYD',
	'HYS',
	'IAD',
	'ICC',
	'ICEB',
	'ICEC',
	'ICED',
	'ICEF',
	'ICEI',
	'ICEL',
	'ICER',
	'ICES',
	'ICEV',
	'ICEW',
	'ICEY',
	'ICL',
	'ICLB',
	'ICVB',
	'ICVC',
	'ICVD',
	'ICVF',
	'ICVI',
	'ICVL',
	'ICVR',
	'ICVS',
	'ICVW',
	'ICVY',
	'IDI',
	'IDSN',
	'IENN',
	'IMD',
	'IMM',
	'IPM',
	'IRE',
	'IREC',
	'IRED',
	'IREW',
	'IRSN',
	'IST',
	'ISTN',
	'ITA',
	'ITAC',
	'ITAE',
	'ITAN',
	'JOUN',
	'JPN',
	'JPNC',
	'JPNE',
	'JPNN',
	'JPNS',
	'JST',
	'KOR',
	'KORN',
	'LANE',
	'LANN',
	'LASE',
	'LASN',
	'LAT',
	'LATN',
	'LAW',
	'LAWE',
	'LAWN',
	'LDA',
	'LDAC',
	'LDAN',
	'LIN',
	'LINC',
	'LINE',
	'LINN',
	'MAE',
	'MAS',
	'MAT',
	'MATC',
	'MATE',
	'MATN',
	'MCB',
	'MCP',
	'MDI',
	'MDS',
	'MGB',
	'MGMN',
	'MGP',
	'MGT',
	'MGTC',
	'MGTN',
	'MHI',
	'MIB',
	'MIBN',
	'MIC',
	'MICN',
	'MIS',
	'MISN',
	'MMI',
	'MPH',
	'MPM',
	'MPS',
	'MSA',
	'MSC',
	'MSCC',
	'MSCN',
	'MST',
	'MUS',
	'MUSB',
	'MUSC',
	'MUSE',
	'MUSN',
	'MUSW',
	'MVM',
	'NAC',
	'NAS',
	'NASC',
	'NCM',
	'NEB',
	'NEBN',
	'NEM',
	'NEMN',
	'NEP',
	'NESN',
	'NEU',
	'NMD',
	'NORN',
	'NPB',
	'NRS',
	'NSA',
	'NSC',
	'NSU',
	'NUB',
	'NUSN',
	'NUT',
	'NUTE',
	'NUTN',
	'NVSC',
	'NVSN',
	'OBG',
	'OEH',
	'OPT',
	'ORI',
	'ORL',
	'ORLN',
	'OSU',
	'OTO',
	'PALN',
	'PAS',
	'PBG',
	'PBI',
	'PBID',
	'PED',
	'PEDN',
	'PENN',
	'PER',
	'PERC',
	'PERL',
	'PERN',
	'PFS',
	'PGG',
	'PHA',
	'PHAN',
	'PHC',
	'PHE',
	'PHEN',
	'PHES',
	'PHI',
	'PHIE',
	'PHIN',
	'PHR',
	'PHS',
	'PHSN',
	'PHY',
	'PHYC',
	'PHYE',
	'PHYN',
	'PLB',
	'PLP',
	'PLPN',
	'PLS',
	'PMD',
	'PMI',
	'PMNN',
	'PMR',
	'POL',
	'POLB',
	'POLC',
	'POLE',
	'POLL',
	'POLN',
	'POLW',
	'POM',
	'POPN',
	'POR',
	'PORE',
	'PORN',
	'PPH',
	'PPP',
	'PSC',
	'PSCC',
	'PSCE',
	'PSCL',
	'PSCN',
	'PSCW',
	'PSU',
	'PSY',
	'PSYN',
	'PTX',
	'PUHN',
	'PUL',
	'PUPN',
	'PVM',
	'PZO',
	'RAD',
	'RAL',
	'RCM',
	'RCMC',
	'RCME',
	'RCMN',
	'RDI',
	'REL',
	'REV',
	'RGE',
	'RHM',
	'RMT',
	'RNU',
	'RON',
	'RSC',
	'RST',
	'RSTC',
	'RSTE',
	'RSTN',
	'RTH',
	'RUS',
	'RUSE',
	'RUSN',
	'RVM',
	'SAF',
	'SAS',
	'SCA',
	'SCAN',
	'SCIE',
	'SCIN',
	'SCSN',
	'SCWN',
	'SEAE',
	'SEAN',
	'SION',
	'SLV',
	'SLVC',
	'SLVN',
	'SOC',
	'SOCC',
	'SOCE',
	'SOCF',
	'SOCN',
	'SOCS',
	'SOCW',
	'SOEN',
	'SPA',
	'SPAC',
	'SPAE',
	'SPAN',
	'SPAW',
	'SPEN',
	'SPH',
	'SSC',
	'SSCN',
	'SSTN',
	'STA',
	'STAC',
	'STAF',
	'STAN',
	'STH',
	'STS',
	'SUR',
	'SVM',
	'SWE',
	'SWEE',
	'SWEN',
	'SWHN',
	'TAGC',
	'TCS',
	'THRN',
	'TSKC',
	'TTP',
	'TXC',
	'TXCE',
	'TXCN',
	'URO',
	'UWP',
	'VCR',
	'VEN',
	'VENN',
	'VET',
	'VMB',
	'VMD',
	'VMDN',
	'VME',
	'VMI',
	'VPT',
	'VSR',
	'VSTN',
	'WAS',
	'WDSN',
	'WELN',
	'WFB',
	'WFBN',
	'WFC',
	'WKL',
	'WLD',
	'WMS',
	'WMSE',
	'WMSN',
	'WMSW',
	'WSC',
	'XXX',
	'XXXN',
	'YYY',
	'ZOO',
	'ZOOE',
	'ZOON'
];

window.courseApp = angular.module("courseApp", ["sharedApp", "ngRoute"]);

courseApp.config(function ($routeProvider) {
	return $routeProvider
		.when("/:workgroupId/:year", {
			templateUrl: "CourseCtrl.html",
			controller: "CourseCtrl",
			resolve: {
				payload: CourseCtrl.getPayload
			}
		})
		.when("/", {
			templateUrl: "CourseCtrl.html",
			controller: "CourseCtrl",
			resolve: {
				payload: CourseCtrl.getPayload
			}
		})
		.otherwise({
			redirectTo: "/"
		});
});

var INIT_STATE = "INIT_STATE";
var NEW_COURSE = "NEW_COURSE";
var CREATE_COURSE = "CREATE_COURSE";
var REMOVE_COURSE = "REMOVE_COURSE";
var UPDATE_COURSE = "UPDATE_COURSE";
var GET_COURSE_CENSUS = "GET_COURSE_CENSUS";
var ADD_SECTION_GROUP = "ADD_SECTION_GROUP";
var REMOVE_SECTION_GROUP = "REMOVE_SECTION_GROUP";
var UPDATE_SECTION_GROUP = "UPDATE_SECTION_GROUP";
var TOGGLE_TERM_FILTER = "TOGGLE_TERM_FILTER";
var CELL_SELECTED = "CELL_SELECTED";
var CLOSE_DETAILS = "CLOSE_DETAILS";
var CLOSE_NEW_COURSE_DETAILS = "CLOSE_NEW_COURSE_DETAILS";
var FETCH_SECTIONS = "FETCH_SECTIONS";
var CREATE_SECTION = "CREATE_SECTION";
var UPDATE_SECTION = "UPDATE_SECTION";
var REMOVE_SECTION = "REMOVE_SECTION";
var UPDATE_TABLE_FILTER = "UPDATE_TABLE_FILTER";
var BEGIN_IMPORT_MODE = "BEGIN_IMPORT_MODE";
var END_IMPORT_MODE = "END_IMPORT_MODE";
var SEARCH_IMPORT_COURSES = "SEARCH_IMPORT_COURSES";
var TOGGLE_IMPORT_COURSE = "TOGGLE_IMPORT_COURSE";

'use strict';

/**
 * @ngdoc function
 * @name ipaClientAngularApp.controller:CourseCtrl
 * @description
 * # CourseCtrl
 * Controller of the ipaClientAngularApp
 */
courseApp.controller('CourseCtrl', ['$scope', '$rootScope', '$routeParams', 'courseActionCreators', 'courseService',
		this.CourseCtrl = function ($scope, $rootScope, $routeParams, courseActionCreators, courseService) {
			$scope.workgroupId = $routeParams.workgroupId;
			$scope.year = $routeParams.year;
			$scope.view = {};
			$scope.sequencePatterns = sequencePatterns; // constants.js file
			$scope.subjectCodes = subjectCodes.map(function (subjectCode) { return {code: subjectCode} }); // constants.js file

			// Generate a few recent academic years for the mass course import mode
			var currentYear = new Date().getFullYear();
			var recentYears = [];
			for(i = currentYear; i > currentYear - 10; i--) {
				recentYears.push({
					year: i,
					academicYear: i + "-" + String(i + 1).slice(2)
				});
			}
			$scope.recentAcademicYears = recentYears;

			$rootScope.$on('courseStateChanged', function (event, data) {
				$scope.view.state = data.state;

				if (data.state.courses.newCourse) {
					// A new course is being created
					$scope.view.selectedEntity = $scope.view.state.courses.newCourse;
					$scope.view.selectedEntityType = "newCourse";
					$scope.$apply();
				} else if (data.state.uiState.selectedCourseId && !data.state.uiState.selectedTermCode) {
					// A course is selected
					$scope.view.selectedEntity = $scope.view.state.courses.list[data.state.uiState.selectedCourseId];
					$scope.view.selectedEntityType = "course";
				} else if (data.state.uiState.selectedCourseId && data.state.uiState.selectedTermCode) {
					// A sectionGroup is selected
					$scope.view.selectedEntityType = "sectionGroup";
					var course = $scope.view.state.courses.list[data.state.uiState.selectedCourseId];
					$scope.view.selectedEntity = $scope.view.state.sectionGroups.selectedSectionGroup || $scope.view.state.sectionGroups.newSectionGroup;

					// Initialize sectionGroup sections if not done already
					if ( $scope.view.selectedEntity
						&& $scope.view.selectedEntity.id
						&& $scope.view.selectedEntity.sectionIds == undefined) {
						courseActionCreators.getSectionsBySectionGroup($scope.view.selectedEntity);
					}

					// Initialize course census if not done already
					if (course.census == undefined) {
						courseActionCreators.getCourseCensus(course);
					}

				} else {
					delete $scope.view.selectedEntity;
				}
			});

			$scope.print = function(){
				window.print();
			};

			$scope.closeDetails = function () {
				if ($scope.view.state.courses.newCourse) {
					courseActionCreators.closeNewCourseDetails();
				} else {
					courseActionCreators.closeDetails();
				}
			};

			$scope.termToggled = function (id) {
				courseActionCreators.toggleTermFilter(id);
			};

			$scope.createCourse = function () {
				if ($scope.newCourseIsValid()) {
					courseActionCreators.createCourse($scope.view.state.courses.newCourse, $scope.workgroupId, $scope.year);
				}
			};

			$scope.newCourseIsValid = function () {
				return $scope.view.state.courses.newCourse.title && $scope.view.state.courses.newCourse.sequencePattern;
			};

			$scope.searchCourses = function (query) {
				return courseService.searchCourses(query).then(function (courseSearchResults) {
					return courseSearchResults.slice(0, 20);
				}, function (err) {
					$rootScope.$emit('toast', {message: "Something went wrong. Please try again.", type: "ERROR"});
				});
			};

			$scope.searchCoursesResultSelected = function ($item, $model, $label, $event) {
				$scope.view.state.courses.newCourse.title = $item.title;
				$scope.view.state.courses.newCourse.subjectCode = $item.subjectCode;
				$scope.view.state.courses.newCourse.courseNumber = $item.courseNumber;
				$scope.view.state.courses.newCourse.effectiveTermCode = $item.effectiveTermCode;
			};

			$scope.addTag = function (item, tagId) {
				courseActionCreators.addTagToCourse($scope.view.selectedEntity, $scope.view.state.tags.list[tagId]);
			};

			$scope.removeTag = function (item, tagId) {
				courseActionCreators.removeTagFromCourse($scope.view.selectedEntity, $scope.view.state.tags.list[tagId]);
			};

			$scope.updateCourse = function () {
				courseActionCreators.updateCourse($scope.view.selectedEntity);
			};

			$scope.addSection = function () {
				var sequenceNumber = $scope.nextSequence();
				var sectionGroupId = $scope.view.selectedEntity.id;
				var section = {
					sectionGroupId: sectionGroupId,
					sequenceNumber: sequenceNumber
				};
				courseActionCreators.createSection(section);
			};

			$scope.updateSection = function (section) {
				courseActionCreators.updateSection(section);
			};

			$scope.deleteSection = function (section) {
				courseActionCreators.deleteSection(section);
			};

			$scope.addSectionGroup = function () {
				courseActionCreators.addSectionGroup($scope.view.state.sectionGroups.newSectionGroup);
			};

			/**
			 * For a given sectionGroup this returns the next sequence number if applicable.
			 * Possible cases:
			 * Numeric:
			 * - no section -> the parent course sequencePattern
			 * - section exists -> null
			 * Alpha:
			 * - no sections -> the parent course sequencePattern + 01
			 * - sections exists -> increments the last section
			 */
			$scope.nextSequence = function () {
				var sg = $scope.view.selectedEntity;
				// SectionGroup does not exist...
				if (!sg.id) { return null; }

				var course = $scope.view.state.courses.list[sg.courseId];
				if (course.isSeries() == false) {
					// Numeric sections: return sequencePattern iff no sections exist
					if (sg.sectionIds && sg.sectionIds.length > 0) { return null; }
					else { return course.sequencePattern; }
				} if (sg.sectionIds && sg.sectionIds.length > 0) {
					// Calculate next section sequence if sections already exist
					var lstSectionId = sg.sectionIds[sg.sectionIds.length - 1];
					var lastSection = $scope.view.state.sections.list[lstSectionId]
					var number = parseInt(lastSection.sequenceNumber.slice(-1)) + 1;
					var character = lastSection.sequenceNumber.slice(0, 1);
					return character + "0" + number;
				} else {
					// Default to 'X01' for the first section
					return course.sequencePattern + "01";
				}
			};

			// Triggered by global search field, redraws table based on query
			$scope.filterTable = function (query) {
				clearTimeout($scope.timeout);
				$scope.timeout = setTimeout(courseActionCreators.updateTableFilter, 700, query);
			};

			/**
			 * Begins import mode, which allows for the mass adding of courses.
			 * @return {[type]} [description]
			 */
			$scope.beginImportMode = function () {
				courseActionCreators.beginImportMode();
			};

			/**
			 * Ends import mode, which allows for the mass adding of courses.
			 * @return {[type]} [description]
			 */
			$scope.endImportMode = function () {
				courseActionCreators.endImportMode();
			};

			/**
			 * Triggers the action to pull mass import courses from DW that
			 * match the selected subjectCode and academicYear
			 */
			$scope.searchImportCourses = function () {
				courseActionCreators.searchImportCourses(
					$scope.view.state.uiState.massImportCode,
					$scope.view.state.uiState.massImportYear,
					$scope.view.state.uiState.massImportPrivate);
			};

			$scope.sectionSeatTotal = function (sectionGroup) {
				return sectionGroup.sectionIds.reduce(function (previousValue, sectionId) {
					return previousValue + $scope.view.state.sections.list[sectionId].seats;
				}, 0);
			};
		}
]);

CourseCtrl.getPayload = function (authService, $route, courseActionCreators) {
	authService.validate(localStorage.getItem('JWT'), $route.current.params.workgroupId, $route.current.params.year).then(function () {
		return courseActionCreators.getInitialState($route.current.params.workgroupId, $route.current.params.year);
	});
}

courseApp.directive("censusChart", this.censusChart = function ($rootScope, $timeout) {
	return {
		restrict: 'E',
		template: '<canvas></canvas>',
		replace: true,
		scope: {
			census: '=',
			scheduleTermState: '=',
			courseId: '='
		},
		link: function (scope, element, attrs) {
			var ctx = element[0].getContext("2d");
			scope.$watchGroup(['census', 'scheduleTermState', 'courseId'], function () {
				if (scope.census == undefined) {
					ctx.textAlign="center";
					ctx.fillText("Loading...", element.width()/2, element.height()/2);
					return;
				}

				var getLastFiveYears = function () {
					var lastFiveYears = [];
					for (var y = 4; y >= 0; y--) { lastFiveYears.push(moment().year() - y); }
					return lastFiveYears;
				};

				var getCurrentCensusForProperty = function (property) {
					var something = getLastFiveYears().map(function (year) {
						return _.find(scope.census, function (c) {
							var matchesTermCode = c.termCode.toString() == year + (scope.scheduleTermState.termCode + '').slice(-2);
							var matchesCurrentCode = c.snapshotCode == "CURRENT";
							return matchesTermCode && matchesCurrentCode;
						});
					}).map(function (c) {
						return c ? c[property] : 0;
					});
					return something;
				};

				var getCensusEnrollmentByCensusCodes = function (snapshotCodes) {
					var censusEnrollment = [];

					// Create an array of currentEnrolledCounts in the order of passed snapshotCodes
					for (var sc = 0; sc < snapshotCodes.length; sc++) {
						var snapshotCodesFound = false;
						for (var c = 0; c < scope.census.length; c++) {
							// If snapshotCode and termCode match push to array and go on to the next snapshotCode
							if (scope.census[c].snapshotCode == snapshotCodes[sc]
								&& scope.census[c].termCode == scope.scheduleTermState.termCode) {
								censusEnrollment.push(scope.census[c].currentEnrolledCount);
								snapshotCodesFound = true;
								break;
							}
						}
						// Fill in 0 for missing snapshotCodes
						if (!snapshotCodesFound) {
							censusEnrollment.push(0);
						}
					}

					return censusEnrollment;
				};

				var type, labels, datasets;

				if (scope.scheduleTermState.isLocked) {	// Locked mode
					var snapshotCodes = ["INSTR_BEG", "DAY5", "DAY10", "DAY15", "CURRENT"];
					type = 'bar';
					labels = snapshotCodes;
					datasets = [
						{
							label: "Census",
							lineTension: 0,
							backgroundColor: "rgba(179,181,198,0.5)",
							borderColor: "rgba(179,181,198,1)",
							pointBackgroundColor: "rgba(179,181,198,1)",
							pointBorderColor: "#fff",
							pointHoverBackgroundColor: "#fff",
							pointHoverBorderColor: "rgba(179,181,198,1)",
							data: getCensusEnrollmentByCensusCodes(snapshotCodes)
						}
					];
				} else { // SG is in historical mode
					type = 'line';
					labels = getLastFiveYears();
					datasets = [
						{
							label: "Seats",
							lineTension: 0,
							backgroundColor: "rgba(179,181,198,0.2)",
							borderColor: "rgba(179,181,198,1)",
							pointBackgroundColor: "rgba(179,181,198,1)",
							pointBorderColor: "#fff",
							pointHoverBackgroundColor: "#fff",
							pointHoverBorderColor: "rgba(179,181,198,1)",
							data: getCurrentCensusForProperty("maxEnrollmentCount")
						},
						{
							label: "Enrollment",
							lineTension: 0,
							backgroundColor: "rgba(200,181,150,0.2)",
							borderColor: "rgba(200,181,150,1)",
							pointBackgroundColor: "rgba(200,181,150,1)",
							pointBorderColor: "#fff",
							pointHoverBackgroundColor: "#fff",
							pointHoverBorderColor: "rgba(179,181,198,1)",
							data: getCurrentCensusForProperty("currentEnrolledCount")
						}
					];
				}

				Chart.defaults.global.defaultFontColor = "#888";
				Chart.defaults.global.tooltips.mode = 'x-axis';

				$timeout(function () {
					var myChart = new Chart(ctx, {
						type: type,
						data: {
							labels: labels,
							datasets: datasets
						},
						options: {
							scales: {
								yAxes: [{
									ticks: {
										beginAtZero: true
									}
								}]
							}
						}
					});
					$rootScope.$on("courseStateChanged", function (event, data) {
						// Destroy chart only if it exists and another cell was selected
						if (myChart && data.actionType == "CELL_SELECTED"
							&& ( data.state.uiState.selectedTermCode != scope.scheduleTermState.termCode || data.state.uiState.selectedCourseId != scope.courseId)) {
							myChart.destroy();
						}
					});
				});

			}, true);
		}
	}
});

/**
 * Provides the main course table in the Courses View
 */
courseApp.directive("courseTable", this.courseTable = function ($rootScope, courseActionCreators) {
	return {
		restrict: 'A',
		link: function (scope, element, attrs) {
			scope.view = {};
			var rerenderStateActions = [
				INIT_STATE,
				NEW_COURSE,
				CREATE_COURSE,
				REMOVE_COURSE,
				UPDATE_COURSE,
				CELL_SELECTED,
				CLOSE_DETAILS,
				CLOSE_NEW_COURSE_DETAILS,
				UPDATE_TABLE_FILTER,
				TOGGLE_TERM_FILTER,
				BEGIN_IMPORT_MODE,
				END_IMPORT_MODE,
				SEARCH_IMPORT_COURSES
			];

			$rootScope.$on('courseStateChanged', function (event, data) {
				// Rerender only if on of the specified state actions
				if (rerenderStateActions.indexOf(data.actionType) < 0) { return; }

				if (data.actionType == CLOSE_DETAILS) {
					// Remove existing highlighting
					element.find('tbody > tr').removeClass("selected-tr");
					element.find('tbody > tr > td').removeClass("selected-td");

					return;
				}

				if (data.actionType == CELL_SELECTED) {
					// Remove existing highlighting
					element.find('tbody > tr').removeClass("selected-tr");
					element.find('tbody > tr > td').removeClass("selected-td");

					if (data.state.uiState.selectedCourseId && !data.state.uiState.selectedTermCode) {
						// Highlight row if a course is selected
						$('tr[data-course-id="' + data.state.uiState.selectedCourseId + '"]').addClass("selected-tr");
					} else if (data.state.uiState.selectedCourseId && data.state.uiState.selectedTermCode) {
						// Highlight single cell if a sectionGroup is selected
						$('tr[data-course-id="' + data.state.uiState.selectedCourseId + '"] td[data-term-code="' + data.state.uiState.selectedTermCode + '"]').addClass("selected-td");
					}

					return;
				}

				scope.view.state = data.state;

				if (data.state.uiState.tableLocked) {
					element.addClass("disabled-courses-table");
				} else {
					element.removeClass("disabled-courses-table");
				}

				// Clear the table
				element.empty();

				// Render the header
				// TODO: Add class 'sorting-asc', 'sorting-desc', or 'sorting' to indicate sort direction
				var header = "<thead><tr><th class=\"\">Course</th>";

				// Filter scope.termDefinitions to only those terms which are enabled by the filter.
				// Store this in termsToRender.
				var termsToRender = [];
				$.each(scope.termDefinitions, function(i, term) {
					if(data.state.filters.enabledTerms.indexOf(Number(term.shortCode)) != -1) {
						termsToRender.push(term);
					}
				});

				$.each(termsToRender, function(i, term) {
					// TODO: Add class 'sorting-asc', 'sorting-desc', or 'sorting' to indicate sort direction
					header += "<th class=\"\">" + term.description + "</th>"
				});

				header += "<th class=\"ui-overlay\"></th></tr></thead>";

				element.append(header);

				// Render the body
				var body = "<tbody></tbody>";

				if (data.state.courses.importList) {
					var coursesArray = data.state.courses.ids.map(function (id) { return data.state.courses.list[id]; });
					var blendedCoursesArray = coursesArray.concat(data.state.courses.importList);
					// TODO: handle different sorting options here
					var sortedBlendedCoursesArray = _.sortBy(blendedCoursesArray, function (course) {
						return course.subjectCode + course.courseNumber + course.sequenceNumber;
					});

					$.each(sortedBlendedCoursesArray, function (rowIdx, course) {
						if (course.id == undefined) {
							body += getImportCourseRow(course, termsToRender, data.state);
						} else {
							body += getCourseRow(rowIdx, course.id, termsToRender, data.state);
						}
					});
				} else {
					$.each(data.state.courses.ids, function (rowIdx, courseId) {
							body += getCourseRow(rowIdx, courseId, termsToRender, data.state);
					});
				}

				element.append(body);
				$('delete-course').popover();
			});

			// Call this once to set up table events.
			element.keypress(function (e) {
				if (e.which == 13) {
					$el = $(e.target);

					if ($el.hasClass('planned-seats')) {
						var courseId = $el.closest("tr").data('course-id');
						var termCode = $el.closest("td").data('term-code').toString();
						var sectionGroupId = $el.closest("td").data('section-group-id');
						var plannedSeats = parseInt($el.val());

						if (sectionGroupId) {
							// Save existing sectionGroup
							var sectionGroup = scope.view.state.sectionGroups.list[sectionGroupId];
							sectionGroup.plannedSeats = plannedSeats;
							courseActionCreators.updateSectionGroup(sectionGroup);
						} else {
							// Create a new sectionGroup
							var sectionGroup = {
								courseId: courseId,
								termCode: termCode,
								plannedSeats: plannedSeats
							};
							courseActionCreators.addSectionGroup(sectionGroup);
						}

						// Important: notify angular since this happends outside of the scope
						scope.$apply();
					}
				}
			});

			// Emit sg-clicked event whenever a table <td> is clicked.
			// I'm sorry. Really.
			element.click(function(e) {
				$el = $(e.target);

				// Delete course
				if ($el.data('event-type') == 'deleteCoursePop') {
					$el.closest('td.ui-overlay').css('visibility', 'visible')
					$el.popover('show');
				} else if ($el.data('event-type') == 'deleteCourse') {
					var courseId = $el.data('course-id');
					var course = scope.view.state.courses.list[courseId];

					courseActionCreators.deleteCourse(course);
					// Important: notify angular since this happends outside of the scope
					scope.$apply();
				} else if ($el.data('event-type') == 'dismissCoursePop') {
					$el.closest('td.ui-overlay').css('visibility', '')
					$el.closest("div.popover").siblings("i.delete-course").popover('hide');
				} else if ($el.data('event-type') == 'addCourse') {
					var index = $el.data('index');

					courseActionCreators.newCourse(index);
					// Important: notify angular since this happends outside of the scope
					scope.$apply();
				} else if ($el.is('td:not(.new-course-td):not(.import-course), td:not(.new-course-td):not(.import-course) *')) {
					// TODO: termCode and courseId may not be found if clicking on the first column ...
					var courseId = $el.closest("tr").data('course-id');
					var termCode = $el.closest("td").data('term-code');

					courseActionCreators.setActiveCell(courseId, termCode);
					// Important: notify angular since this happends outside of the scope
					scope.$apply();
				} else if ($el.is('td.import-course, td.import-course *')) {
					var courseSubjectCode = $el.closest("tr").data('course-subject-code');
					var courseNumber = $el.closest("tr").data('course-number');
					var courseSequencePattern = $el.closest("tr").data('course-sequence-pattern');
					var checkBox = $el.closest("tr").find('div.import-course-check i');

					if (checkBox.hasClass('fa-square-o')) {
						checkBox.removeClass('fa-square-o').addClass('fa-check-square-o');
					} else {
						checkBox.removeClass('fa-check-square-o').addClass('fa-square-o');
					}

					courseActionCreators.toggleImportCourse(courseSubjectCode, courseNumber, courseSequencePattern);
					// Important: notify angular since this happends outside of the scope
					scope.$apply();
				}
			});

		}
	}
});

var getImportCourseRow = function (course, termsToRender, state) {
	var checkboxClass = course.import ? "fa-check-square-o" : "fa-square-o";
	var row = "<tr class=\"odd gradeX\" data-course-subject-code=\"" + course.subjectCode + "\""
		+ "data-course-number=\"" + course.courseNumber + "\" data-course-sequence-pattern=\"" + course.sequencePattern + "\" >"
		+ "<td class=\"import-course course-cell\">"
		+ "<div class=\"import-course-check\"><i class=\"fa " + checkboxClass + "\"></i></div>"
		+ "<div class=\"import-course-description\"><strong>"
		+ course.subjectCode + " " + course.courseNumber + " - " + course.sequencePattern
		+ "</strong><br />" + course.title + "</div></td>";
	$.each(termsToRender, function (i, term) {
		var termCode = term.code;
		var once = true;
		var sectionGroup = _.find(state.sectionGroups.importList, function (sg) {
			return (sg.termCode.slice(-2) == termCode.slice(-2))
				&& (sg.subjectCode == course.subjectCode)
				&& (sg.courseNumber == course.courseNumber)
				&& (sg.sequencePattern == course.sequencePattern)
		});
		var plannedSeats = sectionGroup ? sectionGroup.plannedSeats : "";

		row += "<td data-term-code=\"" + termCode + "\" class=\"sg-cell import-course\"><div>" + plannedSeats + "</div></td>";
	});
	row += "</tr>";
	return row;
};

var getCourseRow = function (rowIdx, courseId, termsToRender, state) {
	var rowClass = "odd gradeX";
	if (state.uiState.selectedCourseId == courseId) {
		rowClass += " selected-tr";
	}
	var row = "<tr class=\"" + rowClass + "\" data-course-id=\"" + courseId + "\" >";

	if (courseId == 0) {
		var numOfColumns = termsToRender.length + 1;
		row += "<td class=\"new-course-td\" colspan=\"" + numOfColumns + "\">Adding a new course</td><td class=\"ui-overlay\"></td>";
	} else {
		var course = state.courses.list[courseId];
		if (course.isFiltered) { return; }

		// First column
		row += "<td class=\"course-cell\"><strong>" + course.subjectCode + " " + course.courseNumber + " - " + course.sequencePattern + "</strong> <br />" + course.title + "<br />";
		if (course.tagIds.length) {
			row += "<div class=\"hidden-print\">Tags:";
			$.each(course.tagIds, function (i, tagId) {
				var tag = state.tags.list[tagId];
				var bgColor = tag.color ? tag.color : "#333";
				row += "<div class=\"label\" style=\"padding: 3px; margin-left: 3px; background-color: " + bgColor + "; color: " + tag.getTextColor() + "; \">" + tag.name + "</div>"
			});
			row += "</div>"
		}
		row += "</td>";

		// Term column(s)
		$.each(termsToRender, function (i, term) {
			var termCode = term.code;
			var sectionGroup = _.find(state.sectionGroups.list, function (sg) { return (sg.termCode == termCode) && (sg.courseId == courseId) });
			var sectionGroupId = sectionGroup ? sectionGroup.id : 0;
			var plannedSeats = sectionGroup ? sectionGroup.plannedSeats : "";

			// Calculate this boolean by comparing the sum of all section seats to the plannedSeats
			var requiresAttention = false;

			row += "<td data-term-code=\"" + termCode + "\" data-section-group-id=\"" + sectionGroupId + "\" class=\"sg-cell\"><div>";

			if (requiresAttention) {
				row += "<div class=\"right-inner-addon form-group\"><i class=\"entypo-attention text-warning\"></i></div>";
			}

			row += "<input type=\"number\" value=\"" + plannedSeats + "\" class=\"form-control planned-seats\"></input>";
			row += "</div></td>";
		});

		// Actions column
		var popoverTemplate = "Are you sure you want to delete " + course.subjectCode + " " + course.courseNumber + " - " + course.sequencePattern + "? <br />\
			<div class='text-center'><button class='btn btn-red' data-event-type='deleteCourse' data-course-id='" + courseId + "'>Delete</button>\
			<button class='btn btn-white' data-event-type='dismissCoursePop'>Cancel</button></div>"
		row += "<td class=\"ui-overlay\"><i class=\"btn add-before entypo-plus-circled\" data-event-type=\"addCourse\" data-index=\"" + rowIdx + "\" ></i>";
		row += "<i class=\"btn delete-sg entypo-minus-circled delete-course\" data-event-type=\"deleteCoursePop\" \
			data-toggle=\"popover\" data-html=\"true\" data-content=\"" + popoverTemplate + "\"></i>";
		row += "<i class=\"btn add-after entypo-plus-circled\" data-event-type=\"addCourse\" data-index=\"" + (rowIdx + 1) + "\" ></i></td>";
	}

	row += "</tr>";
	return row;
};
'use strict';

/**
 * @ngdoc service
 * @name courseApp.courseActionCreators
 * @description
 * # courseActionCreators
 * Service in the courseApp.
 * Central location for sharedState information.
 */
courseApp.service('courseActionCreators', function (courseStateService, courseService, $rootScope, Role) {
	return {
		getInitialState: function (workgroupId, year) {
			courseService.getScheduleByWorkgroupIdAndYear(workgroupId, year).then(function (payload) {
				var action = {
					type: INIT_STATE,
					payload: payload
				};
				courseStateService.reduce(action);
			}, function (err) {
				$rootScope.$emit('toast', {message: "Something went wrong. Please try again.", type: "ERROR"});
			});
		},
		setActiveCell: function (courseId, termCode) {
			var action = {
				type: CELL_SELECTED,
				payload: {
					courseId: courseId,
					termCode: termCode
				}
			};
			courseStateService.reduce(action);
		},
		toggleImportCourse: function (subjectCode, courseNumber, sequencePattern) {
			var action = {
				type: TOGGLE_IMPORT_COURSE,
				payload: {
					subjectCode: subjectCode,
					courseNumber: courseNumber,
					sequencePattern: sequencePattern
				}
			};
			courseStateService.reduce(action);
		},
		closeDetails: function () {
			var action = {
				type: CLOSE_DETAILS,
				payload: {}
			};
			courseStateService.reduce(action);
		},
		closeNewCourseDetails: function () {
			var action = {
				type: CLOSE_NEW_COURSE_DETAILS,
				payload: {}
			};
			courseStateService.reduce(action);
		},
		toggleTermFilter: function (termId) {
			var action = {
				type: TOGGLE_TERM_FILTER,
				payload: {
					termId: termId
				}
			};
			courseStateService.reduce(action);
		},
		addSectionGroup: function (sectionGroup) {
			courseService.addSectionGroup(sectionGroup).then(function (sectionGroup) {
				$rootScope.$emit('toast', {message: "Created course offering for " + sectionGroup.termCode.getTermCodeDisplayName(), type: "SUCCESS"});
				var action = {
					type: ADD_SECTION_GROUP,
					payload: {
						sectionGroup: sectionGroup
					}
				};
				courseStateService.reduce(action);
			}, function (err) {
				$rootScope.$emit('toast', {message: "Something went wrong. Please try again.", type: "ERROR"});
			});
		},
		updateSectionGroup: function (sectionGroup) {
			courseService.updateSectionGroup(sectionGroup).then(function (sectionGroup) {
				$rootScope.$emit('toast', {message: "Updated course offering for " + sectionGroup.termCode.getTermCodeDisplayName(), type: "SUCCESS"});
				var action = {
					type: UPDATE_SECTION_GROUP,
					payload: {
						sectionGroup: sectionGroup
					}
				};
				courseStateService.reduce(action);
			}, function (err) {
				$rootScope.$emit('toast', {message: "Something went wrong. Please try again.", type: "ERROR"});
			});
		},
		deleteCourse: function (course) {
			var courseTitle = course.title;
			courseService.deleteCourse(course).then(function () {
				$rootScope.$emit('toast', { message: "Deleted course " + courseTitle, type: "SUCCESS"} );
				var action = {
					type: REMOVE_COURSE,
					payload: {
						course: course
					}
				};
				courseStateService.reduce(action);
			}, function (err) {
				$rootScope.$emit('toast', { message: "Something went wrong. Please try again.", type: "ERROR"} );
			});
		},
		searchImportCourses: function (subjectCode, year, includePrivate) {
			courseService.searchImportCourses(subjectCode, year, includePrivate).then(function (sectionGroups) {
				var action = {
					type: SEARCH_IMPORT_COURSES,
					payload: {
						subjectCode: subjectCode,
						sectionGroups: sectionGroups
					}
				};
				courseStateService.reduce(action);
			}, function (err) {
				$rootScope.$emit('toast', { message: "Something went wrong. Please try again.", type: "ERROR"} );
			});
		},
		newCourse: function (index) {
			var action = {
				type: NEW_COURSE,
				payload: {
					index: index
				}
			};
			courseStateService.reduce(action);
			// This needs to run after the reducer
			this.setActiveCell(0);
		},
		/**
		 * POSTs to create a course
		 *
		 * @param  newCourse		new course object
		 * @param  workgroupId
		 * @param  year
		 * @returns							created course
		 */
		createCourse: function (newCourse, workgroupId, year) {
			courseService.createCourse(newCourse, workgroupId, year).then(function (createdCourse) {
				$rootScope.$emit('toast', { message: "Created course " + createdCourse.title, type: "SUCCESS"} );
				var action = {
					type: CREATE_COURSE,
					payload: {
						course: createdCourse
					}
				};
				courseStateService.reduce(action);
			}, function (err) {
				$rootScope.$emit('toast', { message: "Something went wrong. Please try again.", type: "ERROR"} );
			});

		},
		updateCourse: function (course) {
			courseService.updateCourse(course).then(function (updatedCourse) {
				$rootScope.$emit('toast', { message: "Updated course " + updatedCourse.title, type: "SUCCESS"} );
				var action = {
					type: UPDATE_COURSE,
					payload: {
						course: updatedCourse
					}
				};
				courseStateService.reduce(action);
			}, function (err) {
				$rootScope.$emit('toast', { message: "Something went wrong. Please try again.", type: "ERROR"} );
			});
		},
		addTagToCourse: function (course, tag) {
			courseService.addTagToCourse(course, tag).then(function (updatedCourse) {
				$rootScope.$emit('toast', { message: "Added tag " + tag.name, type: "SUCCESS"} );
				var action = {
					type: UPDATE_COURSE,
					payload: {
						course: updatedCourse
					}
				};
				courseStateService.reduce(action);
			}, function (err) {
				$rootScope.$emit('toast', { message: "Something went wrong. Please try again.", type: "ERROR"} );
			});
		},
		removeTagFromCourse: function (course, tag) {
			courseService.removeTagFromCourse(course, tag).then(function (updatedCourse) {
				$rootScope.$emit('toast', { message: "Removed tag " + tag.name, type: "SUCCESS"} );
				var action = {
					type: UPDATE_COURSE,
					payload: {
						course: updatedCourse
					}
				};
				courseStateService.reduce(action);
			}, function (err) {
				$rootScope.$emit('toast', { message: "Something went wrong. Please try again.", type: "ERROR"} );
			});
		},
		getSectionsBySectionGroup: function (sectionGroup) {
			courseService.getSectionsBySectionGroupId(sectionGroup.id).then(function (sections) {
				var action = {
					type: FETCH_SECTIONS,
					payload: {
						sectionGroup: sectionGroup,
						sections: sections
					}
				};
				courseStateService.reduce(action);
			}, function (err) {
				$rootScope.$emit('toast', { message: "Something went wrong. Please try again.", type: "ERROR"} );
			});
		},
		updateSection: function (section) {
			courseService.updateSection(section).then(function (section) {
				$rootScope.$emit('toast', { message: "Updated section " + section.sequenceNumber, type: "SUCCESS"} );
				var action = {
					type: UPDATE_SECTION,
					payload: {
						section: section
					}
				};
				courseStateService.reduce(action);
			}, function (err) {
				$rootScope.$emit('toast', { message: "Something went wrong. Please try again.", type: "ERROR"} );
			});
		},
		createSection: function (section) {
			courseService.createSection(section).then(function (section) {
				$rootScope.$emit('toast', { message: "Created section " + section.sequenceNumber, type: "SUCCESS"} );
				var action = {
					type: CREATE_SECTION,
					payload: {
						section: section
					}
				};
				courseStateService.reduce(action);
			}, function (err) {
				$rootScope.$emit('toast', { message: "Something went wrong. Please try again.", type: "ERROR"} );
			});
		},
		deleteSection: function (section) {
			courseService.deleteSection(section).then(function () {
				$rootScope.$emit('toast', { message: "Deleted section " + section.sequenceNumber, type: "SUCCESS"} );
				var action = {
					type: REMOVE_SECTION,
					payload: {
						section: section
					}
				};
				courseStateService.reduce(action);
			}, function (err) {
				$rootScope.$emit('toast', { message: "Something went wrong. Please try again.", type: "ERROR"} );
			});
		},
		updateTableFilter: function (query) {
			var action = {
				type: UPDATE_TABLE_FILTER,
				payload: {
					query: query
				}
			};
			courseStateService.reduce(action);
		},
		beginImportMode: function() {
			var action = {
				type: BEGIN_IMPORT_MODE,
				payload: {}
			};
			courseStateService.reduce(action);
		},
		endImportMode: function() {
			var action = {
				type: END_IMPORT_MODE,
				payload: {}
			};
			courseStateService.reduce(action);
		},
		getCourseCensus: function (course) {
			courseService.getCourseCensus(course).then(function (census) {
				var action = {
					type: GET_COURSE_CENSUS,
					payload: {
						course: course,
						census: census
					}
				};
				courseStateService.reduce(action);
			}, function (err) {
				$rootScope.$emit('toast', { message: "Something went wrong. Please try again.", type: "ERROR"} );
			});
		}
	}
});

'use strict';

/**
 * @ngdoc service
 * @name courseApp.courseService
 * @description
 * # courseService
 * Service in the courseApp.
 * courseApp specific api calls.
 */
courseApp.factory("courseService", this.courseService = function($http, $q) {
	return {
		getScheduleByWorkgroupIdAndYear: function(workgroupId, year) {
			var deferred = $q.defer();

			$http.get(serverRoot + "/api/courseView/workgroups/" + workgroupId + "/years/" + year, { withCredentials: true })
			.success(function(payload) {
				deferred.resolve(payload);
			})
			.error(function() {
				deferred.reject();
			});

			return deferred.promise;
		},
		addSectionGroup: function (sectionGroup) {
			var deferred = $q.defer();

			$http.post(serverRoot + "/api/courseView/sectionGroups/", sectionGroup, { withCredentials: true })
			.success(function(payload) {
				deferred.resolve(payload);
			})
			.error(function() {
				deferred.reject();
			});

			return deferred.promise;
		},
		updateSectionGroup: function (sectionGroup) {
			var deferred = $q.defer();

			$http.put(serverRoot + "/api/courseView/sectionGroups/" + sectionGroup.id, sectionGroup, { withCredentials: true })
			.success(function(payload) {
				deferred.resolve(payload);
			})
			.error(function() {
				deferred.reject();
			});

			return deferred.promise;
		},
		createCourse: function (course, workgroupId, year) {
			var deferred = $q.defer();
			course.tags = [];
			course.tagIds.forEach(function (tagId) {
				course.tags.push({id: parseInt(tagId)});
			});

			$http.post(serverRoot + "/api/courseView/workgroups/" + workgroupId + "/years/" + year + "/courses", course, { withCredentials: true })
			.success(function(payload) {
				deferred.resolve(payload);
			})
			.error(function() {
				deferred.reject();
			});

			return deferred.promise;
		},
		updateCourse: function (course) {
			var deferred = $q.defer();

			$http.put(serverRoot + "/api/courseView/courses/" + course.id, course, { withCredentials: true })
			.success(function(payload) {
				deferred.resolve(payload);
			})
			.error(function() {
				deferred.reject();
			});

			return deferred.promise;
		},
		deleteCourse: function(course) {
			var deferred = $q.defer();

			$http.delete(serverRoot + "/api/courseView/courses/" + course.id, { withCredentials: true })
			.success(function(payload) {
				deferred.resolve(payload);
			})
			.error(function() {
				deferred.reject();
			});

			return deferred.promise;
		},
		searchCourses: function(query) {
			var deferred = $q.defer();

			$http.get(dwUrl + "/courses/search?q=" + query + "&token=" + dwToken)
			.success(function(result) {
				deferred.resolve(result);
			})
			.error(function() {
				deferred.reject();
			});

			return deferred.promise;
		},
		searchImportCourses: function(subjectCode, year, includePrivate) {
			var deferred = $q.defer();
			var privateParam = includePrivate ? "&private=true" : "";

			$http.get(dwUrl + "/sections/search?subjectCode=" + subjectCode + "&academicYear=" + year + "&token=" + dwToken + privateParam)
			.success(function(result) {
				deferred.resolve(result);
			})
			.error(function() {
				deferred.reject();
			});

			return deferred.promise;
		},
		addTagToCourse: function (course, tag) {
			var deferred = $q.defer();

			$http.post(serverRoot + "/api/courseView/courses/" + course.id + "/tags/" + tag.id, tag, { withCredentials: true })
			.success(function(payload) {
				deferred.resolve(payload);
			})
			.error(function() {
				deferred.reject();
			});

			return deferred.promise;
		},
		removeTagFromCourse: function (course, tag) {
			var deferred = $q.defer();

			$http.delete(serverRoot + "/api/courseView/courses/" + course.id + "/tags/" + tag.id, { withCredentials: true })
			.success(function(payload) {
				deferred.resolve(payload);
			})
			.error(function() {
				deferred.reject();
			});

			return deferred.promise;
		},
		getSectionsBySectionGroupId: function (sectionGroupId) {
			var deferred = $q.defer();

			$http.get(serverRoot + "/api/courseView/sectionGroups/" + sectionGroupId + "/sections/", { withCredentials: true })
			.success(function(payload) {
				deferred.resolve(payload);
			})
			.error(function() {
				deferred.reject();
			});

			return deferred.promise;
		},
		updateSection: function (section) {
			var deferred = $q.defer();

			$http.put(serverRoot + "/api/courseView/sections/" + section.id, section, { withCredentials: true })
			.success(function(payload) {
				deferred.resolve(payload);
			})
			.error(function() {
				deferred.reject();
			});

			return deferred.promise;
		},
		createSection: function (section) {
			var deferred = $q.defer();

			$http.post(serverRoot + "/api/courseView/sectionGroups/" + section.sectionGroupId + "/sections", section, { withCredentials: true })
			.success(function(payload) {
				deferred.resolve(payload);
			})
			.error(function() {
				deferred.reject();
			});

			return deferred.promise;
		},
		deleteSection: function (section) {
			var deferred = $q.defer();

			$http.delete(serverRoot + "/api/courseView/sections/" + section.id, { withCredentials: true })
			.success(function(payload) {
				deferred.resolve(payload);
			})
			.error(function() {
				deferred.reject();
			});

			return deferred.promise;
		},
		getCourseCensus: function(course) {
			var deferred = $q.defer();

			$http.get(dwUrl + "/census?subjectCode=" + course.subjectCode + "&courseNumber=" + course.courseNumber + "&token=" + dwToken)
			.success(function(result) {
				deferred.resolve(result);
			})
			.error(function() {
				deferred.reject();
			});

			return deferred.promise;
		}
	};
});

'use strict';

/**
 * @ngdoc service
 * @name courseApp.courseStateService
 * @description
 * # courseStateService
 * Service in the courseApp.
 * Central location for sharedState information.
 */
courseApp.service('courseStateService', function ($rootScope, Course, ScheduleTermState, SectionGroup, Section, Tag) {
	return {
		_state: {},
		_scheduleTermStateReducers: function (action, scheduleTermStates) {
			var scope = this;

			switch (action.type) {
				case INIT_STATE:
					scheduleTermStates = {
						ids: []
					};
					var scheduleTermStateList = {};
					var length = action.payload.scheduleTermStates ? action.payload.scheduleTermStates.length : 0;
					for (var i = 0; i < length; i++) {
						var scheduleTermStateData = action.payload.scheduleTermStates[i];
						// Using termCode as key since the scheduleTermState does not have an id
						scheduleTermStateList[scheduleTermStateData.termCode] = new ScheduleTermState(scheduleTermStateData);
					}
					scheduleTermStates.ids = _array_sortIdsByProperty(scheduleTermStateList, "termCode");
					scheduleTermStates.list = scheduleTermStateList;
					return scheduleTermStates;
				default:
					return scheduleTermStates;
			}
		},
		_courseReducers: function (action, courses) {
			var scope = this;

			switch (action.type) {
				case INIT_STATE:
					courses = {
						newCourse: null,
						ids: [],
						importList: null,
					};
					var coursesList = {};
					var length = action.payload.courses ? action.payload.courses.length : 0;
					for (var i = 0; i < length; i++) {
						var courseData = action.payload.courses[i];
						coursesList[courseData.id] = new Course(courseData);
					}
					courses.ids = _array_sortIdsByProperty(coursesList, ["subjectCode", "courseNumber", "sequencePattern"]);
					courses.list = coursesList;
					return courses;
				case SEARCH_IMPORT_COURSES:
					var importList = [];
					action.payload.sectionGroups.forEach(function (sg) {
						// Find any duplicate in existing courses
						var matchingCourse = _.find(courses.list, function (course) {
							return (course.courseNumber == sg.courseNumber) && (course.sequencePattern == sg.sequencePattern);
						});
						// Find any duplicate in importList
						var matchingImportCourse = _.find(importList, function (course) {
							return (course.courseNumber == sg.courseNumber) && (course.sequencePattern == sg.sequencePattern);
						});
						// Add only non-duplicates
						if (matchingCourse == undefined && matchingImportCourse == undefined) {
							importList.push(new Course({
								subjectCode: action.payload.subjectCode,
								courseNumber: sg.courseNumber,
								title: sg.title,
								sequencePattern: sg.sequencePattern,
								import: true
							}));
						}
					});
					courses.importList = _.sortBy(importList, function (course) {
						return course.subjectCode + course.courseNumber + course.sequenceNumber;
					});
					return courses;
				case TOGGLE_IMPORT_COURSE:
					var matchingImportCourse = _.find(courses.importList, function (course) {
						return (course.subjectCode == action.payload.subjectCode)
							&& (course.courseNumber == action.payload.courseNumber)
							&& (course.sequencePattern == action.payload.sequencePattern);
					});
					if (matchingImportCourse) {
						matchingImportCourse.import = !matchingImportCourse.import;
					}
					return courses;
				case NEW_COURSE:
					// Insert a new id of '0' at the specified index
					courses.ids.splice(action.payload.index, 0, 0);
					courses.newCourse = new Course();
					return courses;
				case CLOSE_NEW_COURSE_DETAILS:
					var newCourseIndex = courses.ids.indexOf(0);
					courses.ids.splice(newCourseIndex, 1);
					courses.newCourse = null;
					return courses;
				case CREATE_COURSE:
					// Close details
					var newCourseIndex = courses.ids.indexOf(0);
					courses.ids.splice(newCourseIndex, 1);
					courses.newCourse = null;
					// Insert new course
					courses.list[action.payload.course.id] = new Course(action.payload.course);
					courses.ids.splice(newCourseIndex, 0, action.payload.course.id);
					return courses;
				case REMOVE_COURSE:
					var courseIndex = courses.ids.indexOf(action.payload.course.id);
					courses.ids.splice(courseIndex, 1);
					delete courses.list[action.payload.course.id];
					return courses;
				case UPDATE_COURSE:
					courses.list[action.payload.course.id] = action.payload.course;
					return courses;
				case UPDATE_TABLE_FILTER:
					var query = action.payload.query.toLowerCase();

					courses.ids.forEach(function (courseId) {
						courses.list[courseId].isFiltered = true;
						for(key in courses.list[courseId]) {
							if (typeof courses.list[courseId][key] == "string"
								&& courses.list[courseId][key].toLowerCase().search(query) >= 0) {
								courses.list[courseId].isFiltered = false;
							}
						}

						return courses.list[courseId];
					});
					return courses;
				case GET_COURSE_CENSUS:
					courses.list[action.payload.course.id].census = action.payload.census;
					return courses;
				case END_IMPORT_MODE:
					courses.importList = null;
					return courses;
				default:
					return courses;
			}
		},
		_sectionGroupReducers: function (action, sectionGroups) {
			var scope = this;

			switch (action.type) {
				case INIT_STATE:
					sectionGroups = {
						newSectionGroup: null,
						selectedSectionGroup: null,
						ids: [],
						importList: null
					};
					var sectionGroupsList = {};
					var length = action.payload.sectionGroups ? action.payload.sectionGroups.length : 0;
					for (var i = 0; i < length; i++) {
						var sectionGroupData = action.payload.sectionGroups[i];
						sectionGroupsList[sectionGroupData.id] = new SectionGroup(sectionGroupData);
						sectionGroups.ids.push(sectionGroupData.id);
					}
					sectionGroups.list = sectionGroupsList;
					return sectionGroups;
				case SEARCH_IMPORT_COURSES:
					sectionGroups.importList = [];
					action.payload.sectionGroups.forEach(function (sg) {
						// Find any duplicate in importList
						var matchingImportSectionGroup = _.find(sectionGroups.importList, function (sectionGroup) {
							return (sectionGroup.courseNumber == sg.courseNumber)
								&& (sectionGroup.sequencePattern == sg.sequencePattern)
								&& (sectionGroup.termCode == sg.termCode);
						});
						// Add only non-duplicates
						if (matchingImportSectionGroup == undefined) {
							sectionGroups.importList.push(new SectionGroup({
								subjectCode: action.payload.subjectCode,
								courseNumber: sg.courseNumber,
								sequencePattern: sg.sequencePattern,
								plannedSeats: sg.seats,
								termCode: sg.termCode
							}));
						}
					});
					return sectionGroups;
				case ADD_SECTION_GROUP:
					sectionGroups.list[action.payload.sectionGroup.id] = new SectionGroup(action.payload.sectionGroup);
					sectionGroups.ids.push(action.payload.sectionGroup.id);
					sectionGroups.selectedSectionGroup = sectionGroups.list[action.payload.sectionGroup.id];
					sectionGroups.newSectionGroup = null;
					return sectionGroups;
				case REMOVE_SECTION_GROUP:
					var sectionGroupIndex = sectionGroups.ids.indexOf(action.payload.sectionGroup.id);
					sectionGroups.ids.splice(sectionGroupIndex, 1);
					delete sectionGroups.list[action.payload.sectionGroup.id];
					return sectionGroups;
				case UPDATE_SECTION_GROUP:
					sectionGroups.list[action.payload.sectionGroup.id] = action.payload.sectionGroup;
					return sectionGroups;
				case FETCH_SECTIONS:
					sectionGroups.list[action.payload.sectionGroup.id].sectionIds = action.payload.sections
						.sort(function (sectionA, sectionB) {
							if (sectionA.sequenceNumber < sectionB.sequenceNumber) { return -1; }
							if (sectionA.sequenceNumber > sectionB.sequenceNumber) { return 1; }
							return 0;
 						})
						.map(function (section) { return section.id; });
					return sectionGroups;
				case CREATE_SECTION:
					sectionGroups.list[action.payload.section.sectionGroupId].sectionIds.push(action.payload.section.id);
					return sectionGroups;
				case REMOVE_SECTION:
					var sectionIdIndex = sectionGroups.list[action.payload.section.sectionGroupId].sectionIds.indexOf(action.payload.section.id);
					sectionGroups.list[action.payload.section.sectionGroupId].sectionIds.splice(sectionIdIndex, 1);
					return sectionGroups;
				case CELL_SELECTED:
					sectionGroups.selectedSectionGroup = _.find(sectionGroups.list, function (sg) {
						return (sg.termCode == action.payload.termCode) && (sg.courseId == action.payload.courseId);
					});
					if (action.payload.termCode && sectionGroups.selectedSectionGroup == undefined) {
						var sectionGroupData = {
							courseId: action.payload.courseId,
							plannedSeats: 0,
							termCode: action.payload.termCode.toString()
						};
						sectionGroups.newSectionGroup = new SectionGroup(sectionGroupData);
					}
					return sectionGroups;
				case CLOSE_DETAILS:
					sectionGroups.selectedSectionGroup = null;
					sectionGroups.newSectionGroup = null;
					return sectionGroups;
				case END_IMPORT_MODE:
					sectionGroups.importList = null;
					return sectionGroups;
				default:
					return sectionGroups;
			}
		},
		_sectionReducers: function (action, sections) {
			var scope = this;

			switch (action.type) {
				case INIT_STATE:
					sections = {
						list: {},
						ids: []
					};
					return sections;
				case FETCH_SECTIONS:
					action.payload.sections.forEach(function (sectionData) {
						sections.list[sectionData.id] = new Section(sectionData);
						sections.ids.push(sectionData.id);
					});
					return sections;
				case CREATE_SECTION:
					sections.list[action.payload.section.id] = new Section(action.payload.section);
					sections.ids.push(action.payload.section.id);
					return sections;
				case REMOVE_SECTION:
					var sectionIndex = sections.ids.indexOf(action.payload.section.id);
					sections.ids.splice(sectionIndex, 1);
					delete sections.list[action.payload.section.id];
					return sections;
				case UPDATE_SECTION:
					sections.list[action.payload.section.id] = action.payload.section;
					return sections;
				default:
					return sections;
			}
		},
		_tagReducers: function (action, tags) {
			var scope = this;

			switch (action.type) {
				case INIT_STATE:
					tags = {
						ids: []
					};
					var tagsList = {};
					var length = action.payload.tags ? action.payload.tags.length : 0;
					for (var i = 0; i < length; i++) {
						var tagData = action.payload.tags[i];
						if (tagData.archived == false) {
							tagsList[tagData.id] = new Tag(tagData);
						}
					}
					tags.ids = _array_sortIdsByProperty(tagsList, "name");
					tags.list = tagsList;
					return tags;
				default:
					return tags;
			}
		},
		_filterReducers: function (action, filters) {
			var scope = this;

			switch (action.type) {
				case INIT_STATE:
					// A filter is 'enabled' if it is checked, i.e. the category it represents
					// is selected to be shown/on/active.
					filters = {
						enabledTerms: [10, 1, 3], // these match the 'id' field in termDefinitions
						enabledTags: [],
						enablePublishedCourses: true,
						enableUnpublishedCourses: false
					};
					// Here is where we might load stored data about what filters
					// were left on last time.
					return filters;
				case TOGGLE_TERM_FILTER:
					var termId = action.payload.termId;
					var idx = filters.enabledTerms.indexOf(termId);
					// A term in the term filter dropdown has been toggled on or off.
					if(idx === -1) {
						// Toggle on
						filters.enabledTerms.push(termId);
					} else {
						// Toggle off
						filters.enabledTerms.splice(idx, 1);
					}
					return filters;
				default:
					return filters;
			}
		},
		_uiStateReducers: function (action, uiState) {
			var scope = this;

			switch (action.type) {
				case INIT_STATE:
					uiState = {
						tableLocked: false,
						selectedCourseId: null,
						selectedTermCode: null,
						massImportMode: false,
						massImportCode: null,
						massImportYear: null,
						massImportPrivate: false
					};
					return uiState;
				case NEW_COURSE:
					uiState.tableLocked = true;
					return uiState;
				case CREATE_COURSE:
					uiState.selectedCourseId = action.payload.course.id;
					uiState.tableLocked = false;
					return uiState;
				case CELL_SELECTED:
					uiState.selectedCourseId = action.payload.courseId;
					uiState.selectedTermCode = action.payload.termCode;
					return uiState;
				case CLOSE_DETAILS:
					uiState.selectedCourseId = null;
					uiState.selectedTermCode = null;
					return uiState;
				case CLOSE_NEW_COURSE_DETAILS:
					uiState.tableLocked = false;
					return uiState;
				case BEGIN_IMPORT_MODE:
					uiState.tableLocked = true;
					uiState.massImportMode = true;
					uiState.selectedCourseId = null;
					uiState.selectedTermCode = null;
					return uiState;
				case END_IMPORT_MODE:
					uiState.tableLocked = false;
					uiState.massImportMode = false;
					uiState.massImportCode = null;
					uiState.massImportYear = null;
					uiState.massImportPrivate = false;
					return uiState;
				default:
					return uiState;
			}
		},
		reduce: function (action) {
			var scope = this;

			if (!action || !action.type) {
				return;
			}

			newState = {};
			newState.scheduleTermStates = scope._scheduleTermStateReducers(action, scope._state.scheduleTermStates);
			newState.courses = scope._courseReducers(action, scope._state.courses);
			newState.sectionGroups = scope._sectionGroupReducers(action, scope._state.sectionGroups);
			newState.sections = scope._sectionReducers(action, scope._state.sections);
			newState.tags = scope._tagReducers(action, scope._state.tags);
			newState.filters = scope._filterReducers(action, scope._state.filters);
			newState.uiState = scope._uiStateReducers(action, scope._state.uiState);

			scope._state = newState;
			$rootScope.$emit('courseStateChanged', {
				state: scope._state,
				actionType: action.type
			});

			console.debug("Course state updated:");
			console.debug(scope._state, action.type);
		}
	}
});
